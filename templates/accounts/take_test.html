{% extends 'base.html' %}

{% block title %}{{ test_attempt.test.title }} - Take Test{% endblock %}

{% block content %}
<!-- Fixed countdown timer at top-right -->
<div id="countdown-timer" class="fixed-top-timer">
    <div class="timer-display" id="timer-display">
        <i class="fas fa-clock"></i>
        <span id="timer-text">Loading...</span>
    </div>
</div>

<div class="container-fluid">
    <!-- Header with test info and question counter -->
    <div class="row mb-3">
        <div class="col-md-8">
            <h4>{{ test_attempt.test.title }}</h4>
            <small class="text-muted">{{ test_attempt.test.description }}</small>
        </div>
        <div class="col-md-4 text-end">
            <h5 class="text-primary">Question {{ question_number }} of {{ total_questions }}</h5>
            <small class="text-muted">Progress: {{ progress_percentage }}%</small>
        </div>
    </div>
    
    <!-- Progress bar -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="progress" style="height: 8px;">
                <div class="progress-bar bg-primary" 
                     role="progressbar" 
                     style="width: {{ progress_percentage }}%"
                     aria-valuenow="{{ progress_percentage }}" 
                     aria-valuemin="0" 
                     aria-valuemax="100">
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main question card -->
    <div class="row justify-content-center">
        <div class="col-lg-8">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">{{ current_question.title }}</h5>
                </div>
                <div class="card-body">
                    <!-- Question content -->
                    <div class="mb-4">
                        <p class="question-text">{{ current_question.description }}</p>
                        {% if current_question.image %}
                        <div class="text-center my-3">
                            <img src="{{ current_question.image.url }}" 
                                 class="img-fluid rounded" 
                                 alt="Question image"
                                 style="max-height: 300px;">
                        </div>
                        {% endif %}
                    </div>
                    
                    <!-- Answer choices -->
                    <div class="answer-choices">
                        {% for choice in current_question.choices.all %}
                        <div class="form-check mb-3">
                            <input class="form-check-input answer-radio" 
                                   type="radio" 
                                   name="answer" 
                                   id="choice_{{ choice.label }}"
                                   value="{{ choice.label }}"
                                   data-question-id="{{ current_question.id }}"
                                   {% if existing_answer and existing_answer.selected_choice == choice.label %}checked{% endif %}>
                            <label class="form-check-label" for="choice_{{ choice.label }}">
                                <strong>{{ choice.label }}.</strong> {{ choice.text }}
                            </label>
                        </div>
                        {% endfor %}
                    </div>
                    
                    <!-- Save feedback -->
                    <div id="save-feedback" class="alert" style="display: none;"></div>
                </div>
                
                <!-- Navigation buttons -->
                <div class="card-footer d-flex justify-content-between">
                    <form method="post" action="{% url 'navigate_question' test_attempt.id %}" class="d-inline">
                        {% csrf_token %}
                        <input type="hidden" name="direction" value="previous">
                        <button type="submit" 
                                class="btn btn-secondary"
                                {% if test_attempt.is_first_question %}disabled{% endif %}>
                            <i class="fas fa-arrow-left"></i> Previous
                        </button>
                    </form>
                    
                    <div class="d-flex gap-2">
                        <small class="text-muted align-self-center">Auto-save enabled</small>
                        <button type="button" class="btn btn-success" id="submit-test-btn">
                            <i class="fas fa-check"></i> Submit Test
                        </button>
                    </div>
                    
                    <form method="post" action="{% url 'navigate_question' test_attempt.id %}" class="d-inline">
                        {% csrf_token %}
                        <input type="hidden" name="direction" value="next">
                        <button type="submit" 
                                class="btn btn-primary"
                                {% if test_attempt.is_last_question %}disabled{% endif %}>
                            Next <i class="fas fa-arrow-right"></i>
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Instructions panel -->
    <div class="row justify-content-center mt-4">
        <div class="col-lg-8">
            <div class="card border-info">
                <div class="card-body p-3">
                    <h6 class="card-title text-info mb-2"><i class="fas fa-info-circle"></i> Instructions</h6>
                    <ul class="mb-0 small">
                        <li>Select one answer for each question by clicking the radio button</li>
                        <li>Your answers are automatically saved when you select them</li>
                        <li>Use Previous/Next buttons to navigate between questions</li>
                        <li>You can change your answers by selecting a different option</li>
                        <li>Progress bar shows how many questions you've answered</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Submission Confirmation Modal -->
    <div class="modal fade" id="submission-modal" tabindex="-1" aria-labelledby="submission-modal-label" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="submission-modal-label">
                        <i class="fas fa-paper-plane"></i> Submit Test
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning">
                        <h6><i class="fas fa-exclamation-triangle"></i> Are you sure you want to submit?</h6>
                        <p class="mb-0">You cannot change your answers after submission.</p>
                    </div>
                    
                    <div class="row text-center mb-3">
                        <div class="col-md-6">
                            <div class="card bg-light">
                                <div class="card-body py-2">
                                    <h5 class="text-success mb-0" id="answered-count">0</h5>
                                    <small class="text-muted">Answered</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card bg-light">
                                <div class="card-body py-2">
                                    <h5 class="text-primary mb-0" id="total-count">0</h5>
                                    <small class="text-muted">Total Questions</small>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="unanswered-warning" class="alert alert-danger" style="display: none;">
                        <h6><i class="fas fa-exclamation-circle"></i> Unanswered Questions</h6>
                        <p class="mb-0">You have <strong id="unanswered-count">0</strong> unanswered question(s). These will be marked as incorrect.</p>
                    </div>
                    
                    <p class="text-muted small">
                        <i class="fas fa-info-circle"></i> 
                        Your answers have been automatically saved. Submitting will finalize your test and calculate your score.
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                        <i class="fas fa-arrow-left"></i> Continue Test
                    </button>
                    <button type="button" class="btn btn-danger" id="confirm-submit-btn">
                        <i class="fas fa-paper-plane"></i> Submit Test
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Hidden submission form -->
    <form id="submission-form" method="post" action="{% url 'submit_test' test_attempt.id %}" style="display: none;">
        {% csrf_token %}
    </form>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const answerRadios = document.querySelectorAll('.answer-radio');
    const saveStatus = document.getElementById('save-feedback');
    const progressBar = document.querySelector('.progress-bar');
    
    // Timer variables
    const timerDisplay = document.getElementById('timer-display');
    const timerText = document.getElementById('timer-text');
    const attemptId = '{{ test_attempt.id }}';
    
    // v1.5.2: Server-authoritative timer (display-only client implementation)
    // Industry pattern: Client timer is UI indicator only, server controls all timing decisions
    const testEndTimeUTC = new Date('{{ test_end_time_utc|date:"c" }}'); // Server-calculated UTC end time
    const serverTimeUTC = new Date('{{ server_time_utc|date:"c" }}');   // Current server UTC time
    const clientStartTime = new Date();                                 // Client reference time
    
    // Server-provided remaining time (authoritative)
    let serverRemainingSeconds = {{ remaining_seconds }};
    const gracePeriodSeconds = {{ grace_period_seconds }};
    
    // AUTO-SUBMIT DEBUG LOGGING SYSTEM
    const autoSubmitLogger = {
        logLevel: 'DEBUG', // DEBUG, INFO, WARN, ERROR
        sessionId: `${attemptId}_${Date.now()}`,
        
        log: function(level, message, data = {}) {
            const timestamp = new Date().toISOString();
            const logEntry = {
                timestamp: timestamp,
                level: level,
                session: this.sessionId,
                attempt_id: attemptId,
                message: message,
                data: data,
                user_agent: navigator.userAgent,
                url: window.location.href
            };
            
            // Always log to console for debugging
            console.log(`[AUTO-SUBMIT-${level}] ${timestamp} - ${message}`, data);
            
            // Send critical logs to server for analysis
            if (level === 'ERROR' || level === 'WARN' || message.includes('auto-submit')) {
                this.sendToServer(logEntry);
            }
            
            // Store in localStorage for analysis
            this.storeLocally(logEntry);
        },
        
        sendToServer: function(logEntry) {
            try {
                fetch('{% url "save_answer" test_attempt.id %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken'),
                        'X-Log-Entry': 'true'
                    },
                    body: JSON.stringify({
                        log_entry: logEntry,
                        log_type: 'auto_submit_debug'
                    })
                }).catch(err => {
                    console.error('Failed to send log to server:', err);
                });
            } catch (error) {
                console.error('Error sending log to server:', error);
            }
        },
        
        storeLocally: function(logEntry) {
            try {
                const logs = JSON.parse(localStorage.getItem('autoSubmitLogs') || '[]');
                logs.push(logEntry);
                // Keep only last 100 logs
                if (logs.length > 100) {
                    logs.splice(0, logs.length - 100);
                }
                localStorage.setItem('autoSubmitLogs', JSON.stringify(logs));
            } catch (error) {
                console.error('Failed to store log locally:', error);
            }
        }
    };
    
    autoSubmitLogger.log('INFO', 'Timer initialization started', {
        testEndTimeUTC: testEndTimeUTC.toISOString(),
        serverTimeUTC: serverTimeUTC.toISOString(),
        serverRemainingSeconds: serverRemainingSeconds,
        gracePeriodSeconds: gracePeriodSeconds,
        userTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        clientStartTime: clientStartTime.toISOString(),
        displayPurposeOnly: 'Client timer is for display only - server controls auto-submit'
    });
    
    // Load timer state from localStorage for persistence
    const timerKey = `test_timer_${attemptId}`;
    let timerState = JSON.parse(localStorage.getItem(timerKey) || '{}');
    let warningShown5min = timerState.warningShown5min || false;
    let warningShown1min = timerState.warningShown1min || false;
    let testSubmitted = timerState.testSubmitted || false;
    
    // Auto-submit attempt tracking for exponential backoff
    let autoSubmitAttempts = 0;
    const maxAutoSubmitAttempts = 3;
    let timerInterval = null;
    
    // Track pending save operations to prevent race conditions
    let pendingSaves = 0;
    
    // Generate unique attempt ID for tracking auto-submit attempts
    function generateAttemptId() {
        return `auto_submit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    let currentAnsweredCount = {{ answered_questions_count }};
    
    // Time tracking for current question
    let questionStartTime = Date.now();
    let totalTestStartTime = new Date('{{ test_attempt.started_at|date:"c" }}');
    
    // Handle answer selection
    answerRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.checked) {
                saveAnswer(this.dataset.questionId, this.value);
            }
        });
    });
    
    // Reset question start time when page loads (for navigation)
    questionStartTime = Date.now();
    
    function saveAnswer(questionId, selectedChoice) {
        // Calculate time spent on this question BEFORE sending request
        const timeSpentSeconds = Math.floor((Date.now() - questionStartTime) / 1000);
        
        // Track this save operation
        pendingSaves++;
        
        fetch(`{% url 'save_answer' test_attempt.id %}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                question_id: questionId,
                selected_choice: selectedChoice,
                time_spent_seconds: timeSpentSeconds
            })
        })
        .then(response => {
            console.log('Save response received:', response.status); // Debug log
            return response.json();
        })
        .then(data => {
            console.log('Save data:', data); // Debug log
            if (data.success) {
                // Update progress bar silently (no success message)
                progressBar.style.width = data.progress_percentage + '%';
                progressBar.setAttribute('aria-valuenow', data.progress_percentage);
                
                // Update progress text
                const progressText = document.querySelector('.col-md-4 small');
                if (progressText) {
                    progressText.textContent = `Progress: ${data.progress_percentage}%`;
                }
                
                // Update current answered count for accurate modal display
                updateAnsweredCount();
                console.log('Answer saved successfully'); // Debug log
            } else {
                console.error('Save failed:', data.error); // Debug log
                showSaveStatus('Error saving answer: ' + data.error, 'danger');
            }
        })
        .catch(error => {
            console.error('Save error:', error); // Debug log
            showSaveStatus('Network error occurred while saving', 'warning');
        })
        .finally(() => {
            // Mark this save operation as complete
            pendingSaves--;
            console.log('Pending saves after completion:', pendingSaves); // Debug log
        });
    }
    
    function showSaveStatus(message, type) {
        saveStatus.className = `alert alert-${type}`;
        saveStatus.textContent = message;
        saveStatus.style.display = 'block';
        
        // Auto-hide non-error messages after 3 seconds
        if (type !== 'danger') {
            setTimeout(() => {
                if (saveStatus.style.display === 'block') {
                    saveStatus.style.display = 'none';
                }
            }, 3000);
        }
    }
    
    function clearSaveStatus() {
        saveStatus.style.display = 'none';
    }
    
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    // CSRF token refresh for long-running test sessions
    async function getValidCSRFToken() {
        try {
            // Try to get a fresh CSRF token
            const response = await fetch('{% url "save_answer" test_attempt.id %}', {
                method: 'GET',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });
            
            if (response.ok) {
                // If the request succeeds, the current token is still valid
                return getCookie('csrftoken');
            } else if (response.status === 403) {
                // CSRF token is stale, try to refresh the page silently to get new token
                console.warn('CSRF token expired, attempting to refresh...');
                window.location.reload();
                return null;
            }
        } catch (error) {
            console.warn('CSRF token validation failed:', error);
        }
        
        // Fallback to current token
        const fallbackToken = getCookie('csrftoken');
        autoSubmitLogger.log('WARN', 'Using fallback CSRF token', {
            fallback_token_present: !!fallbackToken
        });
        return fallbackToken;
    }
    
    // v1.5.2: Display-only timer (server controls actual auto-submit)
    function updateTimer() {
        if (testSubmitted) {
            autoSubmitLogger.log('DEBUG', 'Timer update skipped - test already submitted');
            return;
        }
        
        // Calculate elapsed time since page load
        const elapsedSeconds = Math.floor((new Date() - clientStartTime) / 1000);
        
        // Calculate estimated remaining time (display purpose only)
        const estimatedRemainingSeconds = Math.max(0, serverRemainingSeconds - elapsedSeconds);
        
        // Enhanced logging for troubleshooting
        if (estimatedRemainingSeconds <= 60 && estimatedRemainingSeconds % 10 === 0) {
            autoSubmitLogger.log('DEBUG', 'Timer update - final minute countdown', {
                estimatedRemainingSeconds: estimatedRemainingSeconds,
                serverProvidedRemaining: serverRemainingSeconds,
                elapsedSincePageLoad: elapsedSeconds,
                currentTime: new Date().toISOString(),
                testEndTimeUTC: testEndTimeUTC.toISOString()
            });
        }
        
        // Trigger client-side auto-submit attempt (server will validate)
        if (estimatedRemainingSeconds <= 0) {
            autoSubmitLogger.log('WARN', 'Client timer expired - triggering auto-submit', {
                estimatedRemainingSeconds: estimatedRemainingSeconds,
                serverRemainingSeconds: serverRemainingSeconds,
                elapsedSeconds: elapsedSeconds,
                currentTime: new Date().toISOString(),
                testEndTime: testEndTimeUTC.toISOString(),
                autoSubmitAttempts: autoSubmitAttempts,
                testSubmitted: testSubmitted
            });
            autoSubmitTest();
            return;
        }
        
        // Calculate minutes and seconds for display
        const minutes = Math.floor(estimatedRemainingSeconds / 60);
        const seconds = estimatedRemainingSeconds % 60;
        
        // Format timer display
        const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        timerText.textContent = formattedTime;
        
        // Update timer appearance based on estimated time remaining
        timerDisplay.className = 'timer-display';
        if (estimatedRemainingSeconds <= 60) { // Last minute
            timerDisplay.classList.add('danger');
        } else if (estimatedRemainingSeconds <= 300) { // Last 5 minutes
            timerDisplay.classList.add('warning');
        }
        
        // Show warning alerts (using estimated time for UX)
        if (estimatedRemainingSeconds <= 300 && estimatedRemainingSeconds > 295 && !warningShown5min) {
            showWarningAlert('5 minutes remaining!', 'warning');
            warningShown5min = true;
            saveTimerState();
        }
        
        if (estimatedRemainingSeconds <= 60 && estimatedRemainingSeconds > 55 && !warningShown1min) {
            showWarningAlert('1 minute remaining!', 'danger');
            warningShown1min = true;
            saveTimerState();
        }
    }
    
    function saveTimerState() {
        const state = {
            warningShown5min: warningShown5min,
            warningShown1min: warningShown1min,
            testSubmitted: testSubmitted,
            lastUpdated: new Date().getTime()
        };
        localStorage.setItem(timerKey, JSON.stringify(state));
    }
    
    function showWarningAlert(message, type) {
        // Remove existing alerts
        const existingAlert = document.querySelector('.timer-warning-alert');
        if (existingAlert) {
            existingAlert.remove();
        }
        
        // Create new alert
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} timer-warning-alert`;
        alert.innerHTML = `
            <strong><i class="fas fa-exclamation-triangle"></i> Time Warning</strong><br>
            ${message}
        `;
        
        document.body.appendChild(alert);
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            if (alert.parentNode) {
                alert.remove();
            }
        }, 5000);
    }
    
    async function autoSubmitTest() {
        const attemptId = generateAttemptId();
        
        autoSubmitLogger.log('INFO', 'Auto-submit initiated', {
            attempt_id: attemptId,
            current_attempts: autoSubmitAttempts,
            max_attempts: maxAutoSubmitAttempts,
            test_submitted: testSubmitted,
            timer_interval_active: timerInterval !== null,
            client_time: new Date().toISOString(),
            remaining_seconds: serverRemainingSeconds
        });
        
        // Prevent multiple simultaneous auto-submit attempts
        if (testSubmitted) {
            autoSubmitLogger.log('WARN', 'Auto-submit blocked: already submitted', {
                attempt_id: attemptId,
                test_submitted: testSubmitted
            });
            return;
        }
        
        // Check attempt limit for exponential backoff
        if (autoSubmitAttempts >= maxAutoSubmitAttempts) {
            autoSubmitLogger.log('ERROR', 'Max auto-submit attempts reached', {
                attempt_id: attemptId,
                attempts: autoSubmitAttempts,
                max_attempts: maxAutoSubmitAttempts
            });
            console.error('Max auto-submit attempts reached. Enabling manual submission.');
            showWarningAlert('Auto-submit failed multiple times. Please submit manually.', 'danger');
            enableManualSubmission();
            return;
        }
        
        // CRITICAL FIX: Always clear timer interval first to prevent multiple triggers
        if (timerInterval) {
            autoSubmitLogger.log('INFO', 'Clearing timer interval', {
                attempt_id: attemptId,
                timer_was_active: true
            });
            clearInterval(timerInterval);
            timerInterval = null;
        }
        
        testSubmitted = true;
        autoSubmitAttempts++;
        
        autoSubmitLogger.log('INFO', 'Auto-submit state updated', {
            attempt_id: attemptId,
            test_submitted: testSubmitted,
            attempt_number: autoSubmitAttempts
        });
        
        console.log(`🚀 Auto-submit attempt ${autoSubmitAttempts}/${maxAutoSubmitAttempts} - Server will validate timing`);
        
        autoSubmitLogger.log('INFO', 'UI state preparation', {
            attempt_id: attemptId,
            timer_display: timerText.textContent,
            inputs_to_disable: document.querySelectorAll('input, button').length
        });
        
        saveTimerState();
        timerText.textContent = '00:00';
        timerDisplay.classList.add('danger');
        
        // Show auto-submit message
        showWarningAlert(`Auto-submitting test... (Attempt ${autoSubmitAttempts})`, 'danger');
        
        // Disable all form elements to prevent further interaction
        const allInputs = document.querySelectorAll('input, button');
        allInputs.forEach(input => input.disabled = true);
        
        autoSubmitLogger.log('INFO', 'UI elements disabled', {
            attempt_id: attemptId,
            disabled_elements: allInputs.length
        });
        
        try {
            autoSubmitLogger.log('INFO', 'Getting CSRF token', {
                attempt_id: attemptId,
                current_token: getCookie('csrftoken') ? 'present' : 'missing'
            });
            
            // Get fresh CSRF token for long-running sessions
            const csrfToken = await getValidCSRFToken();
            
            if (!csrfToken) {
                autoSubmitLogger.log('ERROR', 'CSRF token refresh failed - page reload triggered', {
                    attempt_id: attemptId
                });
                // CSRF refresh triggered page reload
                return;
            }
            
            autoSubmitLogger.log('INFO', 'CSRF token validated', {
                attempt_id: attemptId,
                token_length: csrfToken.length
            });
            
            // Calculate exponential backoff delay for retry attempts
            const retryDelay = autoSubmitAttempts > 1 ? Math.pow(2, autoSubmitAttempts - 1) * 1000 : 0;
            
            if (retryDelay > 0) {
                autoSubmitLogger.log('INFO', 'Applying exponential backoff', {
                    attempt_id: attemptId,
                    delay_ms: retryDelay,
                    attempt_number: autoSubmitAttempts
                });
                console.log(`Waiting ${retryDelay}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
            
            const requestPayload = {
                auto_submit: true,
                client_timestamp: new Date().toISOString(),
                trigger_source: `client_timer_v1.5.2_attempt_${autoSubmitAttempts}`,
                attempt_number: autoSubmitAttempts,
                attempt_id: attemptId
            };
            
            autoSubmitLogger.log('INFO', 'Sending auto-submit request', {
                attempt_id: attemptId,
                url: `{% url 'submit_test' test_attempt.id %}`,
                method: 'POST',
                payload: requestPayload,
                csrf_token_present: !!csrfToken
            });
            
            // Auto-submit attempt with fresh token
            const response = await fetch(`{% url 'submit_test' test_attempt.id %}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(requestPayload)
            });
            
            autoSubmitLogger.log('INFO', 'Received response', {
                attempt_id: attemptId,
                status: response.status,
                status_text: response.statusText,
                ok: response.ok,
                headers: {
                    content_type: response.headers.get('content-type')
                }
            });
            
            const data = await response.json();
            console.log('Auto-submit response:', data);
            
            autoSubmitLogger.log('INFO', 'Response data parsed', {
                attempt_id: attemptId,
                response_data: data,
                success: data.success,
                error: data.error
            });
            
            if (data.success) {
                // Server validated and accepted auto-submit
                autoSubmitLogger.log('INFO', 'Auto-submit successful - redirecting', {
                    attempt_id: attemptId,
                    redirect_url: data.redirect_url || '{% url "dashboard" %}',
                    attempt_number: autoSubmitAttempts,
                    total_attempts: autoSubmitAttempts,
                    success: true
                });
                console.log('✅ Server validated auto-submit successful');
                localStorage.removeItem(timerKey); // Clear timer state on success
                window.location.href = data.redirect_url || '{% url "dashboard" %}';
                return;
            } else {
                // Server rejected auto-submit
                autoSubmitLogger.log('WARN', 'Server rejected auto-submit', {
                    attempt_id: attemptId,
                    error: data.error,
                    remaining_seconds: data.remaining_seconds,
                    attempt_number: autoSubmitAttempts,
                    server_response: data
                });
                console.warn('⚠️ Server rejected auto-submit:', data.error);
                
                if (data.remaining_seconds && data.remaining_seconds > 0) {
                    // Time hasn't actually expired yet - restart timer with server time
                    autoSubmitLogger.log('INFO', 'Server time validation - restarting timer', {
                        attempt_id: attemptId,
                        server_remaining_seconds: data.remaining_seconds,
                        client_remaining_seconds: serverRemainingSeconds,
                        time_difference: data.remaining_seconds - serverRemainingSeconds,
                        action: 'restart_timer'
                    });
                    console.log(`Server says ${data.remaining_seconds}s remaining. Restarting timer.`);
                    showWarningAlert(`Server validation: ${data.remaining_seconds}s remaining. Restarting timer.`, 'warning');
                    
                    // CRITICAL FIX: Don't reset testSubmitted here - restart timer properly
                    serverRemainingSeconds = data.remaining_seconds;
                    autoSubmitAttempts = 0; // Reset attempts since time validation says it's too early
                    
                    // Re-enable inputs and restart timer properly
                    allInputs.forEach(input => input.disabled = false);
                    restartTimerWithServerTime();
                    
                } else {
                    // Real error - try again with exponential backoff
                    autoSubmitLogger.log('ERROR', 'Auto-submit failed - scheduling retry', {
                        attempt_id: attemptId,
                        error: data.error,
                        current_attempts: autoSubmitAttempts,
                        max_attempts: maxAutoSubmitAttempts,
                        will_retry: autoSubmitAttempts < maxAutoSubmitAttempts
                    });
                    console.error('Auto-submit failed:', data.error);
                    showWarningAlert(`Auto-submit failed: ${data.error}. Retrying...`, 'warning');
                    
                    // CRITICAL FIX: Don't reset testSubmitted - let exponential backoff handle retry
                    // Re-enable inputs temporarily
                    allInputs.forEach(input => input.disabled = false);
                    
                    // Retry after delay if under attempt limit
                    if (autoSubmitAttempts < maxAutoSubmitAttempts) {
                        testSubmitted = false; // Allow retry
                        setTimeout(() => autoSubmitTest(), 2000); // Retry after 2 seconds
                    } else {
                        enableManualSubmission();
                    }
                }
            }
            
        } catch (error) {
            autoSubmitLogger.log('ERROR', 'Auto-submit network error', {
                attempt_id: attemptId,
                error_message: error.message,
                error_name: error.name,
                error_stack: error.stack,
                attempt_number: autoSubmitAttempts,
                max_attempts: maxAutoSubmitAttempts,
                network_status: navigator.onLine ? 'online' : 'offline',
                will_retry: autoSubmitAttempts < maxAutoSubmitAttempts
            });
            console.error('Auto-submit network error:', error);
            
            // Network error - retry with exponential backoff
            if (autoSubmitAttempts < maxAutoSubmitAttempts) {
                const retryDelay = Math.pow(2, autoSubmitAttempts) * 1000; // 2s, 4s, 8s
                autoSubmitLogger.log('INFO', 'Network error - scheduling retry with exponential backoff', {
                    attempt_id: attemptId,
                    retry_delay_ms: retryDelay,
                    retry_delay_seconds: retryDelay / 1000,
                    current_attempts: autoSubmitAttempts,
                    max_attempts: maxAutoSubmitAttempts
                });
                showWarningAlert(`Network error. Retrying in ${retryDelay/1000}s... (${autoSubmitAttempts}/${maxAutoSubmitAttempts})`, 'warning');
                
                // Re-enable inputs temporarily
                const allInputs = document.querySelectorAll('input, button');
                allInputs.forEach(input => input.disabled = false);
                
                testSubmitted = false; // Allow retry
                setTimeout(() => autoSubmitTest(), retryDelay);
            } else {
                autoSubmitLogger.log('ERROR', 'Max attempts reached after network errors', {
                    attempt_id: attemptId,
                    final_attempt: autoSubmitAttempts,
                    error_type: 'network_error'
                });
                
                showWarningAlert('Network error during auto-submit. Please submit manually.', 'danger');
                enableManualSubmission();
            }
        }
        
        autoSubmitLogger.log('INFO', 'Auto-submit function completed', {
            attempt_id: attemptId,
            final_state: {
                test_submitted: testSubmitted,
                attempts_used: autoSubmitAttempts
            }
        });
    }
    
    function restartTimerWithServerTime() {
        autoSubmitLogger.log('INFO', 'Restarting timer with server time', {
            server_remaining_seconds: serverRemainingSeconds,
            previous_test_submitted: testSubmitted,
            timer_interval_active: timerInterval !== null
        });
        
        // Reset timer state but keep testSubmitted = true to prevent race conditions
        testSubmitted = false;
        warningShown5min = false;
        warningShown1min = false;
        
        // Restart timer with server-provided remaining time
        timerInterval = setInterval(updateTimer, 1000);
        console.log('Timer restarted with server time');
        
        autoSubmitLogger.log('INFO', 'Timer restart completed', {
            new_test_submitted: testSubmitted,
            timer_interval_active: timerInterval !== null,
            warnings_reset: true
        });
    }
    
    function enableManualSubmission() {
        autoSubmitLogger.log('WARN', 'Enabling manual submission fallback', {
            auto_submit_attempts: autoSubmitAttempts,
            max_attempts: maxAutoSubmitAttempts,
            timer_interval_active: timerInterval !== null,
            test_submitted: testSubmitted
        });
        
        // Final fallback - enable manual submission
        testSubmitted = true; // Prevent further auto-submit attempts
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        
        const submitBtn = document.getElementById('submit-test-btn');
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Submit Manually';
            submitBtn.classList.add('btn-warning');
        }
        
        // Re-enable all inputs
        const allInputs = document.querySelectorAll('input, button');
        allInputs.forEach(input => input.disabled = false);
        
        timerText.textContent = 'TIME UP';
        
        autoSubmitLogger.log('INFO', 'Manual submission enabled', {
            submit_button_enabled: submitBtn ? true : false,
            inputs_enabled: allInputs.length,
            timer_display: timerText.textContent
        });
    }
    
    // Start timer
    updateTimer();
    timerInterval = setInterval(updateTimer, 1000);
    
    // v1.5.2: Server-authoritative approach eliminates need for client time sync
    // Note: Time validation is now handled entirely by server
    // Client timer is display-only and does not control auto-submit timing
    console.log('v1.5.2: Using server-authoritative timing - no client time sync needed');
    
    // Submit test functionality
    const submitBtn = document.getElementById('submit-test-btn');
    submitBtn.addEventListener('click', function() {
        if (testSubmitted) return;
        
        console.log('Submit button clicked, pending saves:', pendingSaves); // Debug log
        
        // Check if there are pending save operations
        if (pendingSaves > 0) {
            console.log('Waiting for pending saves...'); // Debug log
            showSaveStatus('Saving your last answer... Please wait.', 'info');
            // Wait for saves to complete, then show modal
            waitForPendingSaves().then(() => {
                console.log('Saves completed, showing modal'); // Debug log
                // Hide the save status message
                clearSaveStatus();
                showSubmissionModal();
            });
        } else {
            console.log('No pending saves, showing modal immediately'); // Debug log
            // Show submission confirmation modal immediately
            showSubmissionModal();
        }
    });
    
    // Add event listener for modal submit button
    document.getElementById('confirm-submit-btn').addEventListener('click', confirmSubmission);
    
    // Auto-focus on first radio button for better UX
    const firstRadio = document.querySelector('.answer-radio');
    if (firstRadio && !document.querySelector('.answer-radio:checked')) {
        firstRadio.focus();
    }
    
    // Function to update current answered count
    function updateAnsweredCount() {
        // Count currently checked radio buttons across all questions
        const checkedAnswers = document.querySelectorAll('.answer-radio:checked');
        const currentPageAnswered = checkedAnswers.length;
        
        // Since we're using single-question navigation, we need to use
        // a more accurate count that accounts for saved answers
        // For now, increment from initial count based on current page state
        if (currentPageAnswered > 0) {
            // This question is answered, so ensure our count reflects it
            const currentQuestionId = document.querySelector('.answer-radio').dataset.questionId;
            // We'll fetch the accurate count when showing the modal
        }
    }
    
    // Function to wait for all pending saves to complete
    function waitForPendingSaves() {
        return new Promise((resolve) => {
            let timeout = 0;
            const checkPending = () => {
                console.log(`Checking pending saves: ${pendingSaves}, timeout: ${timeout}`); // Debug log
                if (pendingSaves === 0) {
                    console.log('All saves completed'); // Debug log
                    resolve();
                } else if (timeout > 50) { // Max 5 seconds wait (50 * 100ms)
                    console.log('Timeout waiting for saves, proceeding anyway'); // Debug log
                    pendingSaves = 0; // Reset to prevent infinite loop
                    resolve();
                } else {
                    timeout++;
                    setTimeout(checkPending, 100); // Check every 100ms
                }
            };
            checkPending();
        });
    }
    
    // Submission modal functionality
    function showSubmissionModal() {
        // Fetch current answered count from server to ensure accuracy
        fetch(`{% url 'save_answer' test_attempt.id %}`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        })
        .then(response => response.json())
        .then(data => {
            const totalQuestions = {{ total_questions }};
            const answeredQuestions = data.answered_count || {{ answered_questions_count }};
            const unansweredQuestions = totalQuestions - answeredQuestions;
            
            // Update modal content with accurate counts
            document.getElementById('answered-count').textContent = answeredQuestions;
            document.getElementById('total-count').textContent = totalQuestions;
            document.getElementById('unanswered-count').textContent = unansweredQuestions;
            
            // Show/hide unanswered warning
            const unansweredWarning = document.getElementById('unanswered-warning');
            if (unansweredQuestions > 0) {
                unansweredWarning.style.display = 'block';
            } else {
                unansweredWarning.style.display = 'none';
            }
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('submission-modal'));
            modal.show();
        })
        .catch(error => {
            console.error('Error fetching answer count:', error);
            // Fallback to original behavior if fetch fails
            const totalQuestions = {{ total_questions }};
            const answeredQuestions = {{ answered_questions_count }};
            const unansweredQuestions = totalQuestions - answeredQuestions;
            
            document.getElementById('answered-count').textContent = answeredQuestions;
            document.getElementById('total-count').textContent = totalQuestions;
            document.getElementById('unanswered-count').textContent = unansweredQuestions;
            
            const unansweredWarning = document.getElementById('unanswered-warning');
            if (unansweredQuestions > 0) {
                unansweredWarning.style.display = 'block';
            } else {
                unansweredWarning.style.display = 'none';
            }
            
            const modal = new bootstrap.Modal(document.getElementById('submission-modal'));
            modal.show();
        });
    }
    
    function confirmSubmission() {
        console.log('confirmSubmission called'); // Debug log
        if (testSubmitted) return;
        
        // Final check for pending saves before submission
        if (pendingSaves > 0) {
            console.log('Waiting for pending saves to complete...');
            showSaveStatus('Finalizing your answers...', 'info');
            
            waitForPendingSaves().then(() => {
                proceedWithSubmission();
            });
        } else {
            proceedWithSubmission();
        }
    }
    
    function proceedWithSubmission() {
        testSubmitted = true;
        
        // CRITICAL FIX: Properly clear timer interval
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        
        saveTimerState();
        
        // Clear timer state from localStorage
        localStorage.removeItem(timerKey);
        
        // Hide modal
        const modalElement = document.getElementById('submission-modal');
        const modal = bootstrap.Modal.getInstance(modalElement) || new bootstrap.Modal(modalElement);
        modal.hide();
        
        // Submit the form
        document.getElementById('submission-form').submit();
    }
});
</script>

<style>
.question-text {
    font-size: 1.1em;
    line-height: 1.6;
}

.answer-choices .form-check {
    padding: 12px;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    transition: all 0.2s ease;
}

.answer-choices .form-check:hover {
    background-color: #f8f9fa;
    border-color: #dee2e6;
}

.answer-choices .form-check:has(.form-check-input:checked) {
    background-color: #e7f3ff;
    border-color: #0d6efd;
}

.form-check-input:focus {
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

.progress {
    background-color: #e9ecef;
}

@media (max-width: 768px) {
    .card-footer {
        flex-direction: column;
        gap: 10px;
    }
    
    .card-footer form,
    .card-footer > div {
        width: 100%;
    }
    
    .card-footer button {
        width: 100%;
    }
    
    .card-footer .d-flex {
        justify-content: center;
    }
}

/* Fixed countdown timer styles */
.fixed-top-timer {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1050;
}

.timer-display {
    background: #007bff;
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    min-width: 120px;
    text-align: center;
    transition: all 0.3s ease;
}

.timer-display.warning {
    background: #ffc107;
    color: #000;
}

.timer-display.danger {
    background: #dc3545;
    color: white;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.timer-display i {
    margin-right: 8px;
}

/* Warning alerts */
.timer-warning-alert {
    position: fixed;
    top: 80px;
    right: 20px;
    z-index: 1040;
    max-width: 300px;
}

@media (max-width: 768px) {
    .fixed-top-timer {
        top: 10px;
        right: 10px;
    }
    
    .timer-display {
        padding: 8px 12px;
        font-size: 16px;
        min-width: 100px;
    }
    
    .timer-warning-alert {
        top: 60px;
        right: 10px;
        max-width: 250px;
    }
}
</style>
{% endblock %}