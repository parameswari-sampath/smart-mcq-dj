{% extends 'base.html' %}

{% block title %}{{ test_attempt.test.title }} - Take Test{% endblock %}

{% block content %}
<!-- Fixed countdown timer at top-right -->
<div id="countdown-timer" class="fixed-top-timer">
    <div class="timer-display" id="timer-display">
        <i class="fas fa-clock"></i>
        <span id="timer-text">Loading...</span>
    </div>
</div>

<div class="container-fluid">
    <!-- Header with test info and question counter -->
    <div class="row mb-3">
        <div class="col-md-8">
            <h4>{{ test_attempt.test.title }}</h4>
            <small class="text-muted">{{ test_attempt.test.description }}</small>
        </div>
        <div class="col-md-4 text-end">
            <h5 class="text-primary">Question {{ question_number }} of {{ total_questions }}</h5>
            <small class="text-muted">Progress: {{ progress_percentage }}%</small>
        </div>
    </div>
    
    <!-- Progress bar -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="progress" style="height: 8px;">
                <div class="progress-bar bg-primary" 
                     role="progressbar" 
                     style="width: {{ progress_percentage }}%"
                     aria-valuenow="{{ progress_percentage }}" 
                     aria-valuemin="0" 
                     aria-valuemax="100">
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main question card -->
    <div class="row justify-content-center">
        <div class="col-lg-8">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">{{ current_question.title }}</h5>
                </div>
                <div class="card-body">
                    <!-- Question content -->
                    <div class="mb-4">
                        <p class="question-text">{{ current_question.description }}</p>
                        {% if current_question.image %}
                        <div class="text-center my-3">
                            <img src="{{ current_question.image.url }}" 
                                 class="img-fluid rounded" 
                                 alt="Question image"
                                 style="max-height: 300px;">
                        </div>
                        {% endif %}
                    </div>
                    
                    <!-- Answer choices -->
                    <div class="answer-choices">
                        {% for choice in current_question.choices.all %}
                        <div class="form-check mb-3">
                            <input class="form-check-input answer-radio" 
                                   type="radio" 
                                   name="answer" 
                                   id="choice_{{ choice.label }}"
                                   value="{{ choice.label }}"
                                   data-question-id="{{ current_question.id }}"
                                   {% if existing_answer and existing_answer.selected_choice == choice.label %}checked{% endif %}>
                            <label class="form-check-label" for="choice_{{ choice.label }}">
                                <strong>{{ choice.label }}.</strong> {{ choice.text }}
                            </label>
                        </div>
                        {% endfor %}
                    </div>
                    
                    <!-- Save feedback -->
                    <div id="save-feedback" class="alert" style="display: none;"></div>
                </div>
                
                <!-- Navigation buttons -->
                <div class="card-footer d-flex justify-content-between">
                    <form method="post" action="{% url 'navigate_question' test_attempt.id %}" class="d-inline">
                        {% csrf_token %}
                        <input type="hidden" name="direction" value="previous">
                        <button type="submit" 
                                class="btn btn-secondary"
                                {% if test_attempt.is_first_question %}disabled{% endif %}>
                            <i class="fas fa-arrow-left"></i> Previous
                        </button>
                    </form>
                    
                    <div class="d-flex gap-2">
                        <small class="text-muted align-self-center">Auto-save enabled</small>
                        <button type="button" class="btn btn-success" id="submit-test-btn">
                            <i class="fas fa-check"></i> Submit Test
                        </button>
                    </div>
                    
                    <form method="post" action="{% url 'navigate_question' test_attempt.id %}" class="d-inline">
                        {% csrf_token %}
                        <input type="hidden" name="direction" value="next">
                        <button type="submit" 
                                class="btn btn-primary"
                                {% if test_attempt.is_last_question %}disabled{% endif %}>
                            Next <i class="fas fa-arrow-right"></i>
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Instructions panel -->
    <div class="row justify-content-center mt-4">
        <div class="col-lg-8">
            <div class="card border-info">
                <div class="card-body p-3">
                    <h6 class="card-title text-info mb-2"><i class="fas fa-info-circle"></i> Instructions</h6>
                    <ul class="mb-0 small">
                        <li>Select one answer for each question by clicking the radio button</li>
                        <li>Your answers are automatically saved when you select them</li>
                        <li>Use Previous/Next buttons to navigate between questions</li>
                        <li>You can change your answers by selecting a different option</li>
                        <li>Progress bar shows how many questions you've answered</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Submission Confirmation Modal -->
    <div class="modal fade" id="submission-modal" tabindex="-1" aria-labelledby="submission-modal-label" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="submission-modal-label">
                        <i class="fas fa-paper-plane"></i> Submit Test
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning">
                        <h6><i class="fas fa-exclamation-triangle"></i> Are you sure you want to submit?</h6>
                        <p class="mb-0">You cannot change your answers after submission.</p>
                    </div>
                    
                    <div class="row text-center mb-3">
                        <div class="col-md-6">
                            <div class="card bg-light">
                                <div class="card-body py-2">
                                    <h5 class="text-success mb-0" id="answered-count">0</h5>
                                    <small class="text-muted">Answered</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card bg-light">
                                <div class="card-body py-2">
                                    <h5 class="text-primary mb-0" id="total-count">0</h5>
                                    <small class="text-muted">Total Questions</small>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="unanswered-warning" class="alert alert-danger" style="display: none;">
                        <h6><i class="fas fa-exclamation-circle"></i> Unanswered Questions</h6>
                        <p class="mb-0">You have <strong id="unanswered-count">0</strong> unanswered question(s). These will be marked as incorrect.</p>
                    </div>
                    
                    <p class="text-muted small">
                        <i class="fas fa-info-circle"></i> 
                        Your answers have been automatically saved. Submitting will finalize your test and calculate your score.
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                        <i class="fas fa-arrow-left"></i> Continue Test
                    </button>
                    <button type="button" class="btn btn-danger" id="confirm-submit-btn">
                        <i class="fas fa-paper-plane"></i> Submit Test
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Hidden submission form -->
    <form id="submission-form" method="post" action="{% url 'submit_test' test_attempt.id %}" style="display: none;">
        {% csrf_token %}
    </form>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const answerRadios = document.querySelectorAll('.answer-radio');
    const saveStatus = document.getElementById('save-feedback');
    const progressBar = document.querySelector('.progress-bar');
    
    // Timer variables
    const timerDisplay = document.getElementById('timer-display');
    const timerText = document.getElementById('timer-text');
    const attemptId = '{{ test_attempt.id }}';
    
    // v1.5.2: Server-authoritative timer (display-only client implementation)
    // Industry pattern: Client timer is UI indicator only, server controls all timing decisions
    const testEndTimeUTC = new Date('{{ test_end_time_utc|date:"c" }}'); // Server-calculated UTC end time
    const serverTimeUTC = new Date('{{ server_time_utc|date:"c" }}');   // Current server UTC time
    const clientStartTime = new Date();                                 // Client reference time
    
    // Server-provided remaining time (authoritative)
    let serverRemainingSeconds = {{ remaining_seconds }};
    const gracePeriodSeconds = {{ grace_period_seconds }};
    
    console.log('v1.5.2 Server-Authoritative Timer:', {
        testEndTimeUTC: testEndTimeUTC.toISOString(),
        serverTimeUTC: serverTimeUTC.toISOString(),
        serverRemainingSeconds: serverRemainingSeconds,
        gracePeriodSeconds: gracePeriodSeconds,
        userTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        displayPurposeOnly: 'Client timer is for display only - server controls auto-submit'
    });
    
    // Load timer state from localStorage for persistence
    const timerKey = `test_timer_${attemptId}`;
    let timerState = JSON.parse(localStorage.getItem(timerKey) || '{}');
    let warningShown5min = timerState.warningShown5min || false;
    let warningShown1min = timerState.warningShown1min || false;
    let testSubmitted = timerState.testSubmitted || false;
    
    // Track pending save operations to prevent race conditions
    let pendingSaves = 0;
    let currentAnsweredCount = {{ answered_questions_count }};
    
    // Time tracking for current question
    let questionStartTime = Date.now();
    let totalTestStartTime = new Date('{{ test_attempt.started_at|date:"c" }}');
    
    // Handle answer selection
    answerRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.checked) {
                saveAnswer(this.dataset.questionId, this.value);
            }
        });
    });
    
    // Reset question start time when page loads (for navigation)
    questionStartTime = Date.now();
    
    function saveAnswer(questionId, selectedChoice) {
        // Calculate time spent on this question BEFORE sending request
        const timeSpentSeconds = Math.floor((Date.now() - questionStartTime) / 1000);
        
        // Track this save operation
        pendingSaves++;
        
        fetch(`{% url 'save_answer' test_attempt.id %}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                question_id: questionId,
                selected_choice: selectedChoice,
                time_spent_seconds: timeSpentSeconds
            })
        })
        .then(response => {
            console.log('Save response received:', response.status); // Debug log
            return response.json();
        })
        .then(data => {
            console.log('Save data:', data); // Debug log
            if (data.success) {
                // Update progress bar silently (no success message)
                progressBar.style.width = data.progress_percentage + '%';
                progressBar.setAttribute('aria-valuenow', data.progress_percentage);
                
                // Update progress text
                const progressText = document.querySelector('.col-md-4 small');
                if (progressText) {
                    progressText.textContent = `Progress: ${data.progress_percentage}%`;
                }
                
                // Update current answered count for accurate modal display
                updateAnsweredCount();
                console.log('Answer saved successfully'); // Debug log
            } else {
                console.error('Save failed:', data.error); // Debug log
                showSaveStatus('Error saving answer: ' + data.error, 'danger');
            }
        })
        .catch(error => {
            console.error('Save error:', error); // Debug log
            showSaveStatus('Network error occurred while saving', 'warning');
        })
        .finally(() => {
            // Mark this save operation as complete
            pendingSaves--;
            console.log('Pending saves after completion:', pendingSaves); // Debug log
        });
    }
    
    function showSaveStatus(message, type) {
        saveStatus.className = `alert alert-${type}`;
        saveStatus.textContent = message;
        saveStatus.style.display = 'block';
        
        // Auto-hide non-error messages after 3 seconds
        if (type !== 'danger') {
            setTimeout(() => {
                if (saveStatus.style.display === 'block') {
                    saveStatus.style.display = 'none';
                }
            }, 3000);
        }
    }
    
    function clearSaveStatus() {
        saveStatus.style.display = 'none';
    }
    
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    // v1.5.2: Display-only timer (server controls actual auto-submit)
    function updateTimer() {
        if (testSubmitted) return;
        
        // Calculate elapsed time since page load
        const elapsedSeconds = Math.floor((new Date() - clientStartTime) / 1000);
        
        // Calculate estimated remaining time (display purpose only)
        const estimatedRemainingSeconds = Math.max(0, serverRemainingSeconds - elapsedSeconds);
        
        // Debug logging for troubleshooting (less frequent to reduce noise)
        if (estimatedRemainingSeconds <= 60 && estimatedRemainingSeconds % 10 === 0) {
            console.log('v1.5.2 Display Timer (Final Minute):', {
                estimatedRemainingSeconds: estimatedRemainingSeconds,
                serverProvidedRemaining: serverRemainingSeconds,
                elapsedSincePageLoad: elapsedSeconds,
                note: 'Display only - server controls actual auto-submit timing'
            });
        }
        
        // Trigger client-side auto-submit attempt (server will validate)
        if (estimatedRemainingSeconds <= 0) {
            console.log('⏰ Client timer expired - attempting auto-submit (server will validate)');
            autoSubmitTest();
            return;
        }
        
        // Calculate minutes and seconds for display
        const minutes = Math.floor(estimatedRemainingSeconds / 60);
        const seconds = estimatedRemainingSeconds % 60;
        
        // Format timer display
        const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        timerText.textContent = formattedTime;
        
        // Update timer appearance based on estimated time remaining
        timerDisplay.className = 'timer-display';
        if (estimatedRemainingSeconds <= 60) { // Last minute
            timerDisplay.classList.add('danger');
        } else if (estimatedRemainingSeconds <= 300) { // Last 5 minutes
            timerDisplay.classList.add('warning');
        }
        
        // Show warning alerts (using estimated time for UX)
        if (estimatedRemainingSeconds <= 300 && estimatedRemainingSeconds > 295 && !warningShown5min) {
            showWarningAlert('5 minutes remaining!', 'warning');
            warningShown5min = true;
            saveTimerState();
        }
        
        if (estimatedRemainingSeconds <= 60 && estimatedRemainingSeconds > 55 && !warningShown1min) {
            showWarningAlert('1 minute remaining!', 'danger');
            warningShown1min = true;
            saveTimerState();
        }
    }
    
    function saveTimerState() {
        const state = {
            warningShown5min: warningShown5min,
            warningShown1min: warningShown1min,
            testSubmitted: testSubmitted,
            lastUpdated: new Date().getTime()
        };
        localStorage.setItem(timerKey, JSON.stringify(state));
    }
    
    function showWarningAlert(message, type) {
        // Remove existing alerts
        const existingAlert = document.querySelector('.timer-warning-alert');
        if (existingAlert) {
            existingAlert.remove();
        }
        
        // Create new alert
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} timer-warning-alert`;
        alert.innerHTML = `
            <strong><i class="fas fa-exclamation-triangle"></i> Time Warning</strong><br>
            ${message}
        `;
        
        document.body.appendChild(alert);
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            if (alert.parentNode) {
                alert.remove();
            }
        }, 5000);
    }
    
    function autoSubmitTest() {
        if (testSubmitted) return;
        
        console.log('🚀 v1.5.2 Auto-submit triggered - Server will validate timing');
        
        testSubmitted = true;
        saveTimerState();
        timerText.textContent = '00:00';
        timerDisplay.classList.add('danger');
        
        // Show auto-submit message
        showWarningAlert('Time is up! Auto-submitting test...', 'danger');
        
        // Disable all form elements to prevent further interaction
        const allInputs = document.querySelectorAll('input, button');
        allInputs.forEach(input => input.disabled = true);
        
        // Clear timer state from localStorage
        localStorage.removeItem(timerKey);
        
        // Immediate auto-submit attempt (server will validate if time actually expired)
        fetch(`{% url 'submit_test' test_attempt.id %}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                auto_submit: true,
                client_timestamp: new Date().toISOString(),
                trigger_source: 'client_timer_v1.5.2'
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log('v1.5.2 Auto-submit response:', data);
            
            if (data.success) {
                // Server validated and accepted auto-submit
                console.log('✅ Server validated auto-submit successful');
                window.location.href = data.redirect_url || '{% url "dashboard" %}';
            } else {
                // Server rejected auto-submit (timing validation failed)
                console.warn('⚠️ Server rejected auto-submit:', data.error);
                
                if (data.remaining_seconds && data.remaining_seconds > 0) {
                    // Time hasn't actually expired yet - server prevented premature submission
                    showWarningAlert(`Server validation: ${data.remaining_seconds}s remaining. Timer will retry.`, 'warning');
                    
                    // Re-enable inputs and continue timer
                    allInputs.forEach(input => input.disabled = false);
                    testSubmitted = false;
                    
                    // Update server remaining time for accuracy
                    serverRemainingSeconds = data.remaining_seconds;
                } else {
                    // Other error - show error and enable manual submission
                    showWarningAlert('Auto-submit validation failed: ' + data.error, 'danger');
                    document.getElementById('submit-test-btn').disabled = false;
                }
            }
        })
        .catch(error => {
            console.error('v1.5.2 Auto-submit network error:', error);
            showWarningAlert('Network error during auto-submit. Please submit manually.', 'danger');
            
            // Re-enable submit button for manual submission
            document.getElementById('submit-test-btn').disabled = false;
            allInputs.forEach(input => input.disabled = false);
            testSubmitted = false;
        });
    }
    
    // Start timer
    updateTimer();
    const timerInterval = setInterval(updateTimer, 1000);
    
    // v1.5.2: Server-authoritative approach eliminates need for client time sync
    // Note: Time validation is now handled entirely by server
    // Client timer is display-only and does not control auto-submit timing
    console.log('v1.5.2: Using server-authoritative timing - no client time sync needed');
    
    // Submit test functionality
    const submitBtn = document.getElementById('submit-test-btn');
    submitBtn.addEventListener('click', function() {
        if (testSubmitted) return;
        
        console.log('Submit button clicked, pending saves:', pendingSaves); // Debug log
        
        // Check if there are pending save operations
        if (pendingSaves > 0) {
            console.log('Waiting for pending saves...'); // Debug log
            showSaveStatus('Saving your last answer... Please wait.', 'info');
            // Wait for saves to complete, then show modal
            waitForPendingSaves().then(() => {
                console.log('Saves completed, showing modal'); // Debug log
                // Hide the save status message
                clearSaveStatus();
                showSubmissionModal();
            });
        } else {
            console.log('No pending saves, showing modal immediately'); // Debug log
            // Show submission confirmation modal immediately
            showSubmissionModal();
        }
    });
    
    // Add event listener for modal submit button
    document.getElementById('confirm-submit-btn').addEventListener('click', confirmSubmission);
    
    // Auto-focus on first radio button for better UX
    const firstRadio = document.querySelector('.answer-radio');
    if (firstRadio && !document.querySelector('.answer-radio:checked')) {
        firstRadio.focus();
    }
    
    // Function to update current answered count
    function updateAnsweredCount() {
        // Count currently checked radio buttons across all questions
        const checkedAnswers = document.querySelectorAll('.answer-radio:checked');
        const currentPageAnswered = checkedAnswers.length;
        
        // Since we're using single-question navigation, we need to use
        // a more accurate count that accounts for saved answers
        // For now, increment from initial count based on current page state
        if (currentPageAnswered > 0) {
            // This question is answered, so ensure our count reflects it
            const currentQuestionId = document.querySelector('.answer-radio').dataset.questionId;
            // We'll fetch the accurate count when showing the modal
        }
    }
    
    // Function to wait for all pending saves to complete
    function waitForPendingSaves() {
        return new Promise((resolve) => {
            let timeout = 0;
            const checkPending = () => {
                console.log(`Checking pending saves: ${pendingSaves}, timeout: ${timeout}`); // Debug log
                if (pendingSaves === 0) {
                    console.log('All saves completed'); // Debug log
                    resolve();
                } else if (timeout > 50) { // Max 5 seconds wait (50 * 100ms)
                    console.log('Timeout waiting for saves, proceeding anyway'); // Debug log
                    pendingSaves = 0; // Reset to prevent infinite loop
                    resolve();
                } else {
                    timeout++;
                    setTimeout(checkPending, 100); // Check every 100ms
                }
            };
            checkPending();
        });
    }
    
    // Submission modal functionality
    function showSubmissionModal() {
        // Fetch current answered count from server to ensure accuracy
        fetch(`{% url 'save_answer' test_attempt.id %}`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        })
        .then(response => response.json())
        .then(data => {
            const totalQuestions = {{ total_questions }};
            const answeredQuestions = data.answered_count || {{ answered_questions_count }};
            const unansweredQuestions = totalQuestions - answeredQuestions;
            
            // Update modal content with accurate counts
            document.getElementById('answered-count').textContent = answeredQuestions;
            document.getElementById('total-count').textContent = totalQuestions;
            document.getElementById('unanswered-count').textContent = unansweredQuestions;
            
            // Show/hide unanswered warning
            const unansweredWarning = document.getElementById('unanswered-warning');
            if (unansweredQuestions > 0) {
                unansweredWarning.style.display = 'block';
            } else {
                unansweredWarning.style.display = 'none';
            }
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('submission-modal'));
            modal.show();
        })
        .catch(error => {
            console.error('Error fetching answer count:', error);
            // Fallback to original behavior if fetch fails
            const totalQuestions = {{ total_questions }};
            const answeredQuestions = {{ answered_questions_count }};
            const unansweredQuestions = totalQuestions - answeredQuestions;
            
            document.getElementById('answered-count').textContent = answeredQuestions;
            document.getElementById('total-count').textContent = totalQuestions;
            document.getElementById('unanswered-count').textContent = unansweredQuestions;
            
            const unansweredWarning = document.getElementById('unanswered-warning');
            if (unansweredQuestions > 0) {
                unansweredWarning.style.display = 'block';
            } else {
                unansweredWarning.style.display = 'none';
            }
            
            const modal = new bootstrap.Modal(document.getElementById('submission-modal'));
            modal.show();
        });
    }
    
    function confirmSubmission() {
        console.log('confirmSubmission called'); // Debug log
        if (testSubmitted) return;
        
        // Final check for pending saves before submission
        if (pendingSaves > 0) {
            console.log('Waiting for pending saves to complete...');
            showSaveStatus('Finalizing your answers...', 'info');
            
            waitForPendingSaves().then(() => {
                proceedWithSubmission();
            });
        } else {
            proceedWithSubmission();
        }
    }
    
    function proceedWithSubmission() {
        testSubmitted = true;
        clearInterval(timerInterval);
        saveTimerState();
        
        // Clear timer state from localStorage
        localStorage.removeItem(timerKey);
        
        // Hide modal
        const modalElement = document.getElementById('submission-modal');
        const modal = bootstrap.Modal.getInstance(modalElement) || new bootstrap.Modal(modalElement);
        modal.hide();
        
        // Submit the form
        document.getElementById('submission-form').submit();
    }
});
</script>

<style>
.question-text {
    font-size: 1.1em;
    line-height: 1.6;
}

.answer-choices .form-check {
    padding: 12px;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    transition: all 0.2s ease;
}

.answer-choices .form-check:hover {
    background-color: #f8f9fa;
    border-color: #dee2e6;
}

.answer-choices .form-check:has(.form-check-input:checked) {
    background-color: #e7f3ff;
    border-color: #0d6efd;
}

.form-check-input:focus {
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

.progress {
    background-color: #e9ecef;
}

@media (max-width: 768px) {
    .card-footer {
        flex-direction: column;
        gap: 10px;
    }
    
    .card-footer form,
    .card-footer > div {
        width: 100%;
    }
    
    .card-footer button {
        width: 100%;
    }
    
    .card-footer .d-flex {
        justify-content: center;
    }
}

/* Fixed countdown timer styles */
.fixed-top-timer {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1050;
}

.timer-display {
    background: #007bff;
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: bold;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    min-width: 120px;
    text-align: center;
    transition: all 0.3s ease;
}

.timer-display.warning {
    background: #ffc107;
    color: #000;
}

.timer-display.danger {
    background: #dc3545;
    color: white;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.timer-display i {
    margin-right: 8px;
}

/* Warning alerts */
.timer-warning-alert {
    position: fixed;
    top: 80px;
    right: 20px;
    z-index: 1040;
    max-width: 300px;
}

@media (max-width: 768px) {
    .fixed-top-timer {
        top: 10px;
        right: 10px;
    }
    
    .timer-display {
        padding: 8px 12px;
        font-size: 16px;
        min-width: 100px;
    }
    
    .timer-warning-alert {
        top: 60px;
        right: 10px;
        max-width: 250px;
    }
}
</style>
{% endblock %}